# -*- coding: utf-8 -*-
"""Copy of object  detection us.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qotQ-JZhdoIgcwe_jTkQv-QbBJQJif94

1.   Cuthbert Musengi R178522R
2.   Norest Hoko  R178490P
"""

from google.colab import drive
drive.mount('/content/drive')

"""# importing libraries"""

# Commented out IPython magic to ensure Python compatibility.
import keras
import os
import cv2     # for capturing videos
import math   # for mathematical operations
import matplotlib.pyplot as plt    # for plotting the images
# %matplotlib inline
import pandas as pd
from glob import glob
from tqdm import tqdm

from tensorflow.keras.layers import Input
from keras.preprocessing.image import load_img
from keras.preprocessing.image import img_to_array
from keras.applications.vgg16 import preprocess_input
from keras.applications.vgg16 import decode_predictions
from keras.applications.vgg16 import VGG16
from tensorflow.keras.preprocessing import image

"""# Calling the vgg16 model"""

model = VGG16()

print(model.summary())

"""#Reading VIDEOS from drive and creating frames """

# Read the video from specified path 
cam = cv2.VideoCapture('/content/drive/My Drive/Colab Notebooks/videos/sample.mp4') 
try: 
    # creating a folder to store the frames 
    if not os.path.exists('/content/images'): 
        os.makedirs('/content/images') 

# if not created then raise error 
except OSError: 
    print ('Error: Creating directory of data') 

# frame 
frameRate = cam.get(5) 
currentframe = 0
while(True): 
    # reading from frame 
    ret,frame = cam.read() 
    if ret: 
        # if video is still left continue creating images 
        name = '/content/images/frame' + str(currentframe) + '.jpg'
        print ('Creating...' + name) 

        # writing the extracted images 
        cv2.imwrite(name, frame) 

        # increasing counter so that it will show how many frames are created 
        currentframe += 1
    else:
      break

# Release all space and windows once done 
cam.release() 
cv2.destroyAllWindows()

import re

# get file names of the frames
col_frames = os.listdir('/content/images/')

# sort file names
#col_frames.sort(key=lambda f: int(re.sub('\D', '', f)))

# empty list to store the frames
col_images=[]

for i in col_frames:
    # read the frames
    img = cv2.imread('/content/images/'+i)
    # append the frames to the list
    col_images.append(img)

i = 1

for frame in [i, i+1]:
    plt.imshow(cv2.cvtColor(col_images[frame], cv2.COLOR_BGR2RGB))
    plt.title("frame: "+str(frame))
    plt.show()

# convert the frames to grayscale
grayA = cv2.cvtColor(col_images[i], cv2.COLOR_BGR2GRAY)
grayB = cv2.cvtColor(col_images[i+1], cv2.COLOR_BGR2GRAY)

# plot the image after frame differencing
plt.imshow(cv2.absdiff(grayB, grayA), cmap = 'gray')
plt.show()

diff_image = cv2.absdiff(grayB, grayA)

# perform image thresholding
ret, thresh = cv2.threshold(diff_image, 30, 255, cv2.THRESH_BINARY)

# plot image after thresholding
plt.imshow(thresh, cmap = 'gray')
plt.show()

import numpy as np
# apply image dilation
kernel = np.ones((3,3),np.uint8)
dilated = cv2.dilate(thresh,kernel,iterations = 1)

# plot dilated image
plt.imshow(dilated, cmap = 'gray')
plt.show()

contours, hierarchy = cv2.findContours(thresh.copy(),cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE)

dmy = col_images[1].copy()

cv2.drawContours(dmy, contours, -1, (0, 255, 0), 3)
plt.imshow(dmy)
plt.show()

try: 
    # creating a folder to store the frames 
    if not os.path.exists('/content/images/saved'): 
        os.makedirs('/content/images/saved') 

# if not created then raise error 
except OSError: 
    print ('Error: Creating directory of data')

pathIn='/content/images/saved'

os.chdir('/content/images')  
path ='/content/images'
 
for file in os.listdir('.'):
  if file.endswith(".jpg"): 
        image = load_img(file, target_size=(224, 224))
        image = img_to_array(image)
        image = image.reshape((1, image.shape[0], image.shape[1], image.shape[2]))
        image = preprocess_input(image)
        pop = model.predict(image)
        label = decode_predictions(pop)
        label = label[0][0]    
        if label[2]*100>80:
          print('%s (%.2f%%)' % (label[1], label[2]*100),file)

"""#combining the Frames"""

font = cv2.FONT_HERSHEY_SIMPLEX
text = ('%s (%.2f%%)' % (label[1], label[2]*100))
org = (50, 50)
fontScale = 1
color = (255, 0, 0)
thickness = 2
   
cv2.putText(dmy,text,org,font,fontScale,color,thickness,cv2.LINE_AA)
cv2.imwrite(pathIn + str(i) + '.jpg',dmy)

pathOut = '/content/drive/My Drive/Colab Notebooks/videos/obj_det.mp4'
fps = 1

frame_array = []
files = [f for f in os.listdir(pathIn) if isfile(join(pathIn, f))]

for i in range(len(files)):
    filename=pathIn + files[i]
    
    #read frames
    img = cv2.imread(filename)
    height, width, layers = img.shape
    size = (width,height)
    frame_array.append(img)

#inserting the frames into an image array
height, width, layers = img.shape
size = (width,height)
out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps,size)
for i in range(len(frame_array)):
    # writing to a image array
    out.write(frame_array[i])
out.release()

model.save('/content/drive/My Drive/Colab Notebooks/videos')